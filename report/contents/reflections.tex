\section{Reflections} \label{sec:Reflections}

\subsection{Use Case Templates} \label{sec:Reflections.UseCaseTemplates}
Originally, no template was used to document the use cases. The intention was
to provide better ones at a later iteration, perhaps by researching the ones
mentioned by Bennett et al. (\citeyear[][p.~157]{bennett2010object}), but
unfortunately there was not enough time, so the little there was had to be
dedicated to the software itself.

\subsection{Nested iterations in Analysis and Design stage}
The Analysis and Design stage of the first iteration was delayed due to
multiple `trial and errors' within it. Appendices \ref{appendix2} and
\ref{appendix3} show a examples of different models which had been incorporated
into the final design, but which were later changed even before the
implementation started -- that is, even before any coding was done. This caused
a reflection on whether the development method was truly iterative, and whether
or not it was more similar to the Waterfall model.

Still, in the author's opinion, spending more time within the analysis and
design stage were very helpful in implementing \emph{SOLID} classes, and as a
result decreased the negative impacts that any refactoring in the code base
would have caused, were it not to have been done as such. In previous
iterations of similar projects by the author, but where the modelling normally
done in the analysis/design stages were neglected, classes ended up with too
many responsibilities and hard coded dependencies, which made any refactoring
very challenging.

\subsection{Dependency Injection} \label{sec:Reflections.DependencyInjection}
Very often during the implementation it was felt that better dependency
injection could be achieved. In classes such as those found in the
\texttt{TransactionsValidators.scala} file there was constant hard-coded
dependency to the \texttt{validation} package. In this instance, a framework
such as \emph{Spring} or \emph{Guice} would have been useful, but unfortunately
time constraints made it unlikely for the author to implement these into the
project. As a result, there is more tight coupling than there could be, but
wherever possible an effort has been made to pass the dependencies as
constructor or method parameters, so as to facilitate testing, among other
things.

\subsection{Validation} \label{sec:Reflections.Validation} 
\textbf{TODO: see if this is still the case at the end of the project}
A lot of thought has been put into where validation should happen. For example,
the constraints of \texttt{Transaction}, \texttt{Category} and \texttt{Entry}
which were used to enforce \emph{double-entry} could have been implemented at
database or application levels, or both. Initially they were implemented in the
business logic.

\subsection{Design Patterns} \label{sec:Reflections.DesignPatterns}
\textbf{TODO: see if this is still the case at the end of the project}
Instead of the original plan to actually apply design patterns by writing
implementations of those manually, the author noticed that the final version of
this project currently uses mainly the patterns already available in the
\emph{Scala} language.

\subsection{Implementation of the Strategy Design Pattern for Parser}
\textbf{TODO: see if this is still the case at the end of the project}
One of the original intentions of the author was to utilise an implementation
of the Strategy Design pattern when loading the user's bank statements into the
system. The current implementation uploads data from CSV files, but making use
of the Strategy pattern, which allows for different implementations of an
algorithm to exist, and for the right one to be chosen while the application is
\emph{running} (\cite[][Ch.~8,~Location~3152]{nikolov2016scala}), would allow
for other formats to be used too. JSON and XML formats come to mind, especially
if a version of the application could be made which would allow for it to
communicate with a banking system's API -- API's (especially RESTful) tend to
favour these two formats.

Unfortunately, the time constraints prevented these to be successfully
implemented and tested at this time.

\subsection{Implementation of Presentation Layer using only Functional Paradigm}
\textbf{THIS MAY HAVE BEEN CHANGED. LAST COMMIT WHERE TRUE WAS b0bae376264f}
After the first iteration of the presentation layer, it was noticed that
perhaps it could be fully implemented in a form more close to that of the
functional paradigm. That is, make it a point to not use \texttt{var}'s, and
only \texttt{val}'s for members (also not change state using Scala Swing's
classes natural mutable fields, such as location, visible, etc -- the effects
from these could be replicated by copying the values of the instances into new
ones). This could have been achieved if the full \texttt{presentation.swing}
package had been implemented from the start with this in mind: have an
interaction mediator within the package, and then make more use of double
dispatch, familiar to the \emph{Visitor Pattern}
(\cite[][Ch.~8,~Location~3943]{nikolov2016scala}). Then, for the actual flow of
the application, a strategy similar to that used by Felleisen et al.
(\citeyear[][Ch.~5]{felleisen2013realm}), where each action would trigger a
function which changes the state of the application, and then the GUI
displaying the new state would be passed recursively to to the main function,
ensures that the immutability of the functional paradigm is maintained
throughout the presentation layer.

Unfortunately, time constraints were once again too tight for this to be fully
implemented.

\subsection{Layering vs Manual Dependency Injection}
One of the original (implicit) goals of this project was to have a hierarchy
system, where each sub-package would not depend super package, but super
packages could depend on sub ones. That is, a highly specialised
\texttt{presentation.swing.frames} package would not depend on elements of the
\texttt{presentation} package, but the \texttt{swing.frames} package would
declare interfaces which would then be implemented by \texttt{presentation}.
What had not been taken into consideration, however, is how the fact that the
super package having to implement the interface would make it difficult to
truly implement dependency injection: the idea was to have the
\texttt{InteractionMediator} implement the lower package's interfaces, so that
it could be passed to the classes of the specialised package. But this would be
a problem when the interface is too specialised. Therefore, a compromise had to
be made and the interfaces had to be made more generic.

\subsection{Not Implemented}
Unfortunately, the only feature actually delivered was a very crude
implementation of the manual entry feature.  The business logic for
classification, which would enable the uploading of statements, has also been
created, but the linking of it to the GUI was not done in time.

The \texttt{PersistenceMediator} class should be handling exceptions which
might be thrown by \texttt{PersistenceBridge}'s every time the first calls the
latter's methods. The intention of allowing the Mediator to catch exceptions
was because this could then be passed to the user as informative messages, or
be handled internally depending on the nature of the exception (e.g.,
connection exceptions would have to be handled internally, and exceptions
related to user input should be passed to the user). Therefore, some exceptions
should be handled by the \texttt{PersistenceBridge}, and others by the
mediator. Unfortunately, time constraints prevented this from happening.

\textbf{TODO: talk about having to make a decision between making the
specialised modules more independent by having them depend on code in the same
layer, and having code duplication, such as with the Mediators which depend on
two different traits}
