\section{Reflections} \label{sec:Reflections}

\subsection{Use Case Templates} \label{sec:Reflections.UseCaseTemplates}
Originally, no template was used to document the use cases. The intention was
to provide better ones at a later iteration, perhaps by researching the ones
mentioned by Bennett et al. (\citeyear[][p.~157]{bennett2010object}), but
unfortunately there was not enough time, so the little there was had to be
dedicated to the software itself.

\subsection{Nested iterations in Analysis and Design stage}
The Analysis and Design stage of the first iteration was delayed due to
multiple `trial and errors' within it. Appendices \ref{appendix2} and
\ref{appendix3} show a examples of different models which had been incorporated
into the final design, but which were later changed even before the
implementation started -- that is, even before any coding was done. This caused
a reflection on whether the development method was truly iterative, and whether
or not it was more similar to the Waterfall model.

Still, in the author's opinion, spending more time within the analysis and
design stage were very helpful in implementing \emph{SOLID} classes, and as a
result decreased the negative impacts that any refactoring in the code base
would have caused, were it not to have been done as such. In previous
iterations of similar projects by the author, but where the modelling normally
done in the analysis/design stages were neglected, classes ended up with too
many responsibilities and hard coded dependencies, which made any refactoring
very challenging.

\subsection{Dependency Injection} \label{sec:Reflections.DependencyInjection}
Very often during the implementation it was felt that better dependency
injection could be achieved. In classes such as those found in the
\texttt{TransactionsValidators.scala} file there was constant hard-coded
dependency to the \texttt{validation} package. In this instance, a framework
such as \emph{Spring} or \emph{Guice} would have been useful, but unfortunately
time constraints made it unlikely for the author to implement these into the
project. As a result, there is more tight coupling than there could be, but
wherever possible an effort has been made to pass the dependencies as
constructor or method parameters, so as to facilitate testing, among other
things.

\subsection{Validation} \label{sec:Reflections.Validation} 
\textbf{TODO: see if this is still the case at the end of the project}
A lot of thought has been put into where validation should happen. For example,
the constraints of \texttt{Transaction}, \texttt{Category} and \texttt{Entry}
which were used to enforce \emph{double-entry} could have been implemented at
database or application levels, or both. Initially they were implemented in the
business logic.

\subsection{Design Patterns} \label{sec:Reflections.DesignPatterns}
\textbf{TODO: see if this is still the case at the end of the project}
Instead of the original plan to actually apply design patterns by writing
implementations of those manually, the author noticed that the final version of
this project currently uses mainly the patterns already available in the
\emph{Scala} language.

\subsection{Implementation of the Strategy Design Pattern for Parser}
\textbf{TODO: see if this is still the case at the end of the project}
One of the original intentions of the author was to utilise an implementation
of the Strategy Design pattern when loading the user's bank statements into the
system. The current implementation uploads data from CSV files, but making use
of the Strategy pattern, which allows for different implementations of an
algorithm to exist, and for the right one to be chosen while the application is
\emph{running} (\cite[][Ch.~8,~Location~3152]{nikolov2016scala}), would allow
for other formats to be used too. JSON and XML formats come to mind, especially
if a version of the application could be made which would allow for it to
communicate with a banking system's API -- API's (especially RESTful) tend to
favour these two formats.

Unfortunately, the time constraints prevented these to be successfully
implemented and tested at this time.
