\section{Implementation} \label{sec:Implementation}

\subsection{Scala Case Classes} \label{sec:Reflections.ScalaCaseClasses}
One of the benefits of Scala are its case classes. They are very useful for
pattern matching, but also come with a few perks such as the \texttt{copy()}
method. This method allows for the class to be copied with some or all its
members modified. It could be said that it is a language-native implementation
of the \emph{Prototype Design Pattern}
(\cite[][Ch.~6,~Location~2461]{nikolov2016scala}), and throughout the
implementation and testing stage it proved to be a useful feature.

Its utilisation can be seen in the \texttt{Transaction} class, as one of the
tools used to add entries to a \texttt{Category} without having to change the
state of a specific instance -- more similar to what is done in the
\emph{Functional Programming} paradigm:
{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=32,
    lastline=38,
    caption={
      extract of the \texttt{Transaction} class showing the \texttt{copy()}
      method in action
    }
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Transaction.scala}
}


\subsection{Presentation Layer} \label{sec:Implementation.Presentation}
In the presentation layer, for the first iteration, the \emph{Scala Swing}
package was used for building most its aspects. The package consists of Scala
wrappers for the \emph{Java Swing} package, and one of the reasons why it was
chosen was that, as with many other GUI packages, it already comes with an
implementation of the \emph{Observer Design Pattern}
(\cite[][]{gamma1995design}) in its capacity to react to events
(\cite[][p.~5]{maier2009scala};
\cite[][Ch.~9,~Location~3731]{nikolov2016scala}).

\begin{sloppypar}
  The application starts by implementing the \texttt{MainMenu} class, which
  extends the \texttt{SimpleSwingApplication} abstract class from the
  \texttt{scala.swing} package. The class has an implementation of a \emph{main
  method}, therefore it acts as an entry point for the application to run. It
  also contains a \texttt{MainFrame}, which is a Swing \texttt{Frame} -- ``a
  window containing arbitrary data''
  (\cite[][Ch.~34,~Section~34.1]{odersky2016scala})-- which switches off the
  application when closed. It also has implementations of other methods to
  allow the application to close gracefully
  (\cite[][p.~2~\&~3]{maier2009scala}), so with these aspects implemented, it
  allows development to be focused on functionality more relevant to the
  application's logic itself.
\end{sloppypar}


\subsection{Business Logic} \label{sec:Implementation.BusinessLogic}

\textbf{TODO: write about Scala's own implementation of Mockito as one of the
language features}

\textbf{TODO: syntax highlighting for code listings}

\textbf{TODO: write about how using properties file is a good way to decide
otherwise static behaviour at runtime -- is this dependency injection?}

\textbf{TODO: Write about how one of the advantages of scala is how it tries to
enforce the Universal Access. For example, Arrays and Lists implement the
interface (which I think is Iterable) which allows the user to completely
ignore how the data is implemented and access both as lists}

\textbf{TODO: write about why Validator has an auxiliary method for type --
generics would affect the interface. The Validator was created as a trait in
the first place to allow for lesser coupling between the classes which need
validation}

\textbf{TODO: write about why I chose to do integration tests rather than unit}

\textbf{TODO: Read the lightbend guide
https://www.lightbend.com/lagom-framework to Scala and Microservices}

\textbf{TODO: see if the below still makes sense}
The constraints from \texttt{Transaction} and \texttt{Pattern} were implemented
in the business logic code as follows:
{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=15,
    lastline=24,
    caption={
      method to validate \texttt{Transaction} entries
    },
    label=DescriptiveLabel
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Transaction.scala}
}

{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=4,
    lastline=16,
    caption={
      snippet of \texttt{Pattern} showing requirement for it to have at least one Category
    }
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Patterns.scala}
}

As Fowler (\citeyear[][]{fowler1997analysis}), one of the classes should be
responsible for keeping track of the relationship. As seen above, it was
decided that each \texttt{Category} will keep track of its patterns, and this
will at the same time enforce the constraint at the application layer level.


\textbf{TODO: talk about the choice of ListBuffer for constant append and
prepend time (\cite[][location~15415]{odersky2016scala}), and
List[Map[String,Category]] for Classifier -- each map links the same Category
to all its patterns, and since Maps have O(1) high probability/almost constant
time, it was felt that this would be the best implementation for it. The
mapping would work similar to this:} 

\begin{lstlisting}
Welcome to Scala 2.12.4 (Java HotSpot(TM) 64-Bit 
  Server VM, Java 1.8.0_161).
Type in expressions for evaluation. Or try :help.

scala> class K
defined class K

scala> val k = new K
k: K = K@6dc1dc69

scala> val map = Map(1 -> k, 2 -> k)
map: scala.collection.immutable.Map[Int,K] = Map(
  1 -> K@6dc1dc69, 2 -> K@6dc1dc69)

scala> map(1)
res0: K = K@6dc1dc69

scala> map(1) == map(2)
res1: Boolean = true

scala> val map2 = new K
map2: K = K@5fdb7394

scala> val k2 = new K
k2: K = K@70ee1963

scala> val map2 = Map(1 -> k, 2 -> k2)
map2: scala.collection.immutable.Map[Int,K] = Map(
  1 -> K@6dc1dc69, 2 -> K@70ee1963)

scala> map2(1) == map2(2)
res2: Boolean = false

\end{lstlisting}

\textbf{TODO: talk about the decision to create constructor dependencies to
traits rather than classes directly, as is the case with
\texttt{DateStringParser}}

\textbf{TODO: talk about choosing not to user the Builder pattern for the Entry
class as it would turn into boilerplate town}


\subsection{The Bridge Pattern}
The Bridge pattern allows for an abstraction and its implementation to be
decoupled, so that both can vary independently
(\cite[][Ch.~7,Location~2699]{nikolov2016scala}). In this project, the bridge
pattern can be seen implemented in the \emph{presentation} and
\emph{persistence} layers. In the first, the \texttt{Presentation} class is
linked to the \texttt{PresentationBridge} trait by aggregation. The
\texttt{Swing} class implements this trait and refers to the \emph{swing}
package for the implementation. This was done so that the implementation of the
\emph{presentation} layer can change easily at runtime -- for example, if there
are a hosted and a portable version of the application, the first which runs on
a web framework and the latter with a desktop package such as Swing, the same
application can be implemented to both without the code having to be
recompiled.

Another feature which facilitates this is the fact that the clients -- the
\texttt{Presentation} class -- uses a combination of a
\texttt{java.util.Properties} object and \emph{reflection} to determine which
implementation it will run. This will also aid the above goal of having the
behaviour of the application change without it having to be recompiled.


\subsection{Algebraic Data Types and the Value Object Pattern}
Throughout the code, examples of Algebraic Data Types can be seen. These appear
in the form of sealed traits and case objects, and are normally used when
instances need to be passed around as values, but also contain information
which will be relevant to the code. Examples of these can be found in the
\texttt{ConnectionType} hierarchy, where the number of possible instances for
each case class would classify the trait and its subtypes as \emph{Product
Types} (\cite[][p.~411]{wampler2015programming}). The code listing below
illustrates this:

{
  \small
  \lstinputlisting[
    language=Scala,
    caption={
      extract of the \texttt{ConnectionType} hierarchy showing the case classes
      used as value objects
    }
  ]{../code/src/main/scala/personalfinance/persistence/connections/ConnectionType.scala}
}

Algebraic data types could be said to be the natural implementation of the
Value Object design pattern. This pattern is used widely for comparison of
objects not by their identities, but rather by their values. They consist of
small, immutable objects, and the instances of the case classes can be
classified as just those (\cite[][Ch.~8,~Location~3068]{nikolov2016scala}).
