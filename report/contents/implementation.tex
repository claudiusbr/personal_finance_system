\section{Implementation} \label{sec:Implementation}

\subsection{Scala Case Classes} \label{sec:Reflections.ScalaCaseClasses}
One of the benefits of Scala are its case classes. They are very useful for
pattern matching, but also come with a few perks such as the \texttt{copy()}
method. This method allows for the class to be copied with some or all its
members modified. It could be said that it is a language-native implementation
of the \emph{Prototype Design Pattern}
(\cite[][Ch.~6,~Location~2461]{nikolov2016scala}), and throughout the
implementation and testing stage it proved to be a useful feature.

Its utilisation can be seen in the \texttt{Transaction} class, as one of the
tools used to add entries to a \texttt{Category} without having to change the
state of a specific instance -- more similar to what is done in the
\emph{Functional Programming} paradigm:
{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=32,
    lastline=38,
    caption={
      extract of the \texttt{Transaction} class showing the \texttt{copy()}
      method in action
    }
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Transaction.scala}
}


\subsection{Presentation Layer} \label{sec:Implementation.Presentation}
In the presentation layer, for the first iteration, the \emph{Scala Swing}
package was used for building most its aspects. The package consists of Scala
wrappers for the \emph{Java Swing} package, and one of the reasons why it was
chosen was that, as with many other GUI packages, it already comes with an
implementation of the \emph{Observer Design Pattern}
(\cite[][]{gamma1995design}) in its capacity to react to events
(\cite[][p.~5]{maier2009scala};
\cite[][Ch.~9,~Location~3731]{nikolov2016scala}).

\begin{sloppypar}
  The application starts by implementing the \texttt{MainMenu} class, which
  extends the \texttt{SimpleSwingApplication} abstract class from the
  \texttt{scala.swing} package. The class has an implementation of a \emph{main
  method}, therefore it acts as an entry point for the application to run. It
  also contains a \texttt{MainFrame}, which is a Swing \texttt{Frame} -- ``a
  window containing arbitrary data''
  (\cite[][Ch.~34,~Section~34.1]{odersky2016scala})-- which switches off the
  application when closed. It also has implementations of other methods to
  allow the application to close gracefully
  (\cite[][p.~2~\&~3]{maier2009scala}), so with these aspects implemented, it
  allows development to be focused on functionality more relevant to the
  application's logic itself.
\end{sloppypar}


\subsection{Business Logic} \label{sec:Implementation.BusinessLogic}

\textbf{Write about how one of the advantages of scala is how it tries to
enforce the Universal Access. For example, Arrays and Lists implement the
interface (which I think is Iterable) which allows the user to completely
ignore how the data is implemented and access both as lists}

\textbf{TODO: write about why Validator has an auxiliary method for type --
generics would affect the interface. The Validator was created as a trait in
the first place to allow for lesser coupling between the classes which need
validation}

\textbf{TODO: write about why I chose BDD as my form of TDD, if there's space
write about the BehaviourTester class. Include Scala's infix notation as one of
the reasons}

\textbf{TODO: write about why I chose to do integration tests rather than unit}

\textbf{TODO: Read the lightbend guide
https://www.lightbend.com/lagom-framework to Scala and Microservices}

\textbf{TODO: see if the below still makes sense}
The constraints from \texttt{Transaction} and \texttt{Pattern} were implemented
in the business logic code as follows:
{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=15,
    lastline=24,
    caption={
      method to validate \texttt{Transaction} entries
    },
    label=DescriptiveLabel
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Transaction.scala}
}

{
  \small
  \lstinputlisting[
    language=Scala,
    firstline=4,
    lastline=16,
    caption={
      snippet of \texttt{Pattern} showing requirement for it to have at least one Category
    }
  ]{../code/src/main/scala/personalfinance/businesslogic/transaction/Patterns.scala}
}

As Fowler (\citeyear[][]{fowler1997analysis}), one of the classes should be
responsible for keeping track of the relationship. As seen above, it was
decided that each \texttt{Category} will keep track of its patterns, and this
will at the same time enforce the constraint at the application layer level.
